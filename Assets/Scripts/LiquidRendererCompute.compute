// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main
#pragma kernel main2
#include "Assets/Scripts/CreateLiquid.cs.hlsl"

float ParticlesLength;
StructuredBuffer<ScreenParticle> ScreenParticles;

float4 CellsDimension;
RWStructuredBuffer<ScreenCell> ScreenCells;
RWStructuredBuffer<ScreenCell> ScreenCellsBlurred;

float4 ScreenGrabDimensions;
Texture2D<float4> ScreenGrab;
RWTexture2D<float4> Output;

//todo make world normal
float3 GetScreenNormal(float2 clipPoint, in ScreenParticle screenParticle)
{
    float distFromCenter = distance(screenParticle.ClipPosition, clipPoint);
    float2 toEdge = clipPoint - screenParticle.ClipPosition;
    float2 toEdgeDir = normalize(toEdge);
    float3 tangent = float3(toEdgeDir.x, toEdgeDir.y, 0);
    float3 ortho = float3(0, 0, 1);

    float distFromCenterNorm = distFromCenter / screenParticle.Radius;

    //todo we need to acos interp it I think not just a lerp it to be correct for spheres
    float3 normal = lerp(ortho, tangent, distFromCenterNorm);
    return normalize(normal);
}

[numthreads(8,8,1)]
void main (uint3 id : SV_DispatchThreadID)
{
    int indexFlat = id.x + id.y * CellsDimension.x;
    
    ScreenCell cell = ScreenCells[indexFlat];
    cell.Alpha = 0;
    cell.NearestNormal = float3(0,0,-1);
    cell.NearestParticle = 1000000;
    cell.FarthestParticle = -1000000;

    float2 cellScreenPos = float2((float) id.x / CellsDimension.x, (float) id.y / CellsDimension.y);
    for (int k = 0; k < ParticlesLength; k++)
    {
        ScreenParticle part = ScreenParticles[k];
        //todo make this the distance to the sphere at screen... not just the center
        float screenDist = distance(cellScreenPos, part.ClipPosition.xy);
        if (screenDist < part.Radius)
        {
            float distance = part.CameraDepth;
            cell.Alpha = lerp(cell.Alpha, 1, 0.1f);
            if (distance < cell.NearestParticle)
            {
                cell.NearestNormal = GetScreenNormal(cellScreenPos, part);
            }

            cell.NearestParticle = min(cell.NearestParticle, distance);
            cell.FarthestParticle = max(cell.FarthestParticle, distance);
        }
    }

    ScreenCells[indexFlat] = cell;
}

void blendCells(inout ScreenCell cell, in ScreenCell other, float blendAmount)
{
    //todo this breaks normal... stop this
    cell.NearestNormal = normalize(lerp(cell.NearestNormal, other.NearestNormal, blendAmount));
    cell.Alpha = lerp(cell.Alpha, other.Alpha, blendAmount);
}

//todo go based on output texture
[numthreads(8,8,1)]
void main2 (uint3 id : SV_DispatchThreadID)
{
    float2 index2D = id.xy;
    float2 scaleAmount = ScreenGrabDimensions.xy /CellsDimension.xy;
    float2 index2DGrab = id.xy * scaleAmount;
    int indexFlat = id.x + id.y * CellsDimension.x;
    Output[index2D] = id.xyzx;
    
    ScreenCell cell = ScreenCells[indexFlat];
    //BLUR ------------------
    int horizontalIncrement = 2;
    int verticalIncrement = CellsDimension.x*2;

    float blendAmount = 0.6;
    blendCells(cell, ScreenCells[indexFlat + horizontalIncrement + horizontalIncrement], blendAmount);
    blendCells(cell, ScreenCells[indexFlat - horizontalIncrement - horizontalIncrement], blendAmount);
    blendCells(cell, ScreenCells[indexFlat + verticalIncrement + verticalIncrement], blendAmount);
    blendCells(cell, ScreenCells[indexFlat - verticalIncrement - verticalIncrement], blendAmount);
    //BLUR ---------------

    //render
    Output[index2D] = float4(cell.NearestNormal.xyz, cell.Alpha);
    float refractionAmount = 70;
    float2 refractedUV = cell.NearestNormal.xy * refractionAmount * cell.Alpha + index2DGrab;

    float4 blueTint = float4 (.4,.8,1,1);
    float4 blueConstant = float4 (.4,.5,1,1);
    float4 screenGrab = ScreenGrab[index2DGrab];
    float4 refractedPixel = ScreenGrab[refractedUV];

    float4 refractedAndTinted = blueTint * refractedPixel;
    float4 refractedAndTintedAndConstant = lerp(refractedAndTinted, blueConstant, 0.2);
    
    if (cell.Alpha >  0.2)
    {
        Output[index2D] = float4(refractedAndTintedAndConstant.xyz, cell.Alpha);
    }
    else
    {
        Output[index2D] = float4(0,0,0,0);
    }
    // Output[index2D] = float4(cell.NearestNormal, 1);

    // reflect()
    //render
}

//use circles for uv map...
//then before final rendering... use uv offset for entire render with full resolution.....