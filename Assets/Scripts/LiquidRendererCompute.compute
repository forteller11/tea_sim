// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main
#pragma kernel blurKernal
#pragma kernel main2
#include "Assets/Scripts/CreateLiquid.cs.hlsl"

float ParticlesLength;
StructuredBuffer<ScreenParticle> ScreenParticles;

float4 CellsDimension;
RWStructuredBuffer<ScreenCell> ScreenCells;
RWStructuredBuffer<ScreenCell> ScreenCells2;

float4 ScreenGrabDimensions;
Texture2D<float4> ScreenGrab;
RWTexture2D<float4> Output;

float4 LightPosition = float4(5,0,0,20);
float AlphaAtCenter;
float AlphaAtEdge;
float AlphaThreshold;

float4 BaseColor;
float4 BaseTint;

//todo make world normal or get clip light
float3 cameraToViewPosition(float4 cameraPos)
{
    float3 viewPos =  cameraPos.xyz / cameraPos.w;
    viewPos = (viewPos + 1) /2; //from -1,1 to 0,1;
    return viewPos;
}

float3 GetScreenNormal(float2 clipPoint, in ScreenParticle screenParticle)
{
    float3 viewPos = cameraToViewPosition(screenParticle.CameraPosition);
    float distFromCenter = distance(viewPos, clipPoint);
    float2 toEdge = clipPoint - viewPos;
    float2 toEdgeDir = normalize(toEdge);
    float3 tangent = float3(toEdgeDir.x, toEdgeDir.y, 0);
    float3 ortho = float3(0, 0, 1);

    float distFromCenterNorm = distFromCenter / screenParticle.Radius;

    //todo we need to acos interp it I think not just a lerp it to be correct for spheres
    float3 normal = lerp(ortho, tangent, distFromCenterNorm);
    return normalize(normal);
}

//assumes w is a homoegenous coord

[numthreads(8,8,1)]
void main (uint3 id : SV_DispatchThreadID)
{
    int indexFlat = id.x + id.y * CellsDimension.x;
    
    ScreenCell cell = ScreenCells[indexFlat];
    cell.Alpha = 0;
    cell.NearestNormal = float3(0,0,-1);
    cell.NearestParticle = float3( 1000000, 100000, 100000);
    cell.FurthestParticle = float3(-1000000,-100000,-100000);

    float2 cellScreenPos = float2((float) id.x / CellsDimension.x, (float) id.y / CellsDimension.y);
    for (int k = 0; k < ParticlesLength; k++)
    {
        ScreenParticle part = ScreenParticles[k];
        //todo make this the distance to the sphere at screen... not just the center
        float2 partScreenPos = cameraToViewPosition(part.CameraPosition);
        float distFromCellToPartCenter = distance(cellScreenPos, partScreenPos.xy);
        if (distFromCellToPartCenter < part.Radius)
        {
            float percentToEdge = distFromCellToPartCenter / part.Radius;
            float alpha = lerp(AlphaAtCenter, AlphaAtEdge, percentToEdge);
            cell.Alpha = lerp(cell.Alpha, 1, alpha);
            
            if (distFromCellToPartCenter < part.Radius)
            {
                cell.NearestNormal = GetScreenNormal(cellScreenPos, part);
                cell.NearestParticle = part.CameraPosition;
            }
        }
    }

    ScreenCells[indexFlat] = cell;
}

//remember to renormalize at the end!
void weightedAdd(inout ScreenCell cell, in ScreenCell other, float addedWeight)
{
    //this breaks normal... must be renormalized at the end
    cell.NearestNormal = lerp(cell.NearestNormal, other.NearestNormal, addedWeight);
    
    cell.Alpha += other.Alpha * addedWeight;
    cell.FurthestParticle += other.FurthestParticle * addedWeight;
    cell.NearestParticle += other.NearestParticle * addedWeight;
}

//this isn't technically a box blur because the kernal is not currently shaped like a box... it has 8 pixels missing
//[x][ ][x][ ][x]
//[ ][x][x][x][ ]
//[x][x][x][x][x]
//[ ][x][x][x][ ]
//[x][ ][x][ ][x]
ScreenCell boxBlurScreenCell(int2 index, RWStructuredBuffer<ScreenCell> cellsSrc)
{
    int indexFlat = index.x + index.y * CellsDimension.x;
    int horizontalIncrement = 1;
    int verticalIncrement = CellsDimension.x;

    ScreenCell cell;
    cell.Alpha = 0;
    cell.NearestNormal = float3(0,0,0);
    cell.FurthestParticle = 0;
    cell.NearestParticle = 0;
    
    float selfWeight = 0.16;
    float manhatten1Weight = 0.06;
    float manhatten2Weight = 0.05; //58
    float diagonalWeight1 = 0.05; // 74
    float diagonalWeight2 = 0.05;
    
    weightedAdd(cell, cellsSrc[indexFlat], selfWeight);
    
    //manhatten nearest
    weightedAdd(cell, cellsSrc[indexFlat + horizontalIncrement], manhatten1Weight);
    weightedAdd(cell, cellsSrc[indexFlat - horizontalIncrement], manhatten1Weight);
    weightedAdd(cell, cellsSrc[indexFlat + verticalIncrement], manhatten1Weight);
    weightedAdd(cell, cellsSrc[indexFlat - verticalIncrement], manhatten1Weight);

    //diagonal nearest
    weightedAdd(cell, cellsSrc[indexFlat + horizontalIncrement + verticalIncrement], diagonalWeight1);
    weightedAdd(cell, cellsSrc[indexFlat - horizontalIncrement + verticalIncrement], diagonalWeight1);
    weightedAdd(cell, cellsSrc[indexFlat + horizontalIncrement - verticalIncrement], diagonalWeight1);
    weightedAdd(cell, cellsSrc[indexFlat - horizontalIncrement - verticalIncrement], diagonalWeight1);

    //manhatten non nearest
    weightedAdd(cell, cellsSrc[indexFlat + horizontalIncrement * 2], manhatten2Weight);
    weightedAdd(cell, cellsSrc[indexFlat - horizontalIncrement * 2], manhatten2Weight);
    weightedAdd(cell, cellsSrc[indexFlat + verticalIncrement * 2], manhatten2Weight);
    weightedAdd(cell, cellsSrc[indexFlat - verticalIncrement * 2], manhatten2Weight);

    //diagonal non nearest
    weightedAdd(cell, cellsSrc[indexFlat + (horizontalIncrement + verticalIncrement) * 2], diagonalWeight2);
    weightedAdd(cell, cellsSrc[indexFlat - (horizontalIncrement + verticalIncrement) * 2], diagonalWeight2);
    weightedAdd(cell, cellsSrc[indexFlat + (horizontalIncrement - verticalIncrement) * 2], diagonalWeight2);
    weightedAdd(cell, cellsSrc[indexFlat - (horizontalIncrement - verticalIncrement) * 2], diagonalWeight2);

    cell.NearestNormal = normalize(cell.NearestNormal);
    return cell;
}

[numthreads(8,8,1)]
void blurKernal (uint3 id : SV_DispatchThreadID)
{
    float2 index2D = id.xy;
    int indexFlat = index2D.x + index2D.y * CellsDimension.x;
    
    ScreenCells2[indexFlat] = boxBlurScreenCell(index2D, ScreenCells);
    //ScreenCells2[indexFlat] = ScreenCells[indexFlat];
}

//todo go based on output texture
[numthreads(8,8,1)]
void main2 (uint3 id : SV_DispatchThreadID)
{
    float2 index2D = id.xy;
    int indexFlat = index2D.x + index2D.y * CellsDimension.x;
    float2 scaleAmount = ScreenGrabDimensions.xy /CellsDimension.xy;
    float2 index2DGrab = id.xy * scaleAmount;

    ScreenCell cell = ScreenCells2[indexFlat];
    //ScreenCell cell = boxBlurScreenCell(id.xy, ScreenCells);

    //render
    float refractionAmount = 10;
    float2 refractedUV = cell.NearestNormal.xy * refractionAmount * (cell.Alpha+0.3) + index2DGrab;

    float4 refractedPixel = ScreenGrab[refractedUV];

    float4 refractedAndTinted = BaseTint * refractedPixel;
    float4 refractedAndTintedAndConstant = lerp(refractedAndTinted, BaseColor, 0.2);
    
    float3 lightDir = normalize(LightPosition.xyz);
    float3 reflectedRay = normalize(reflect(lightDir, cell.NearestNormal));
    float amountReflectedNormal = max(dot(float3(0,0,1), reflectedRay), 0.5);

    float specular = amountReflectedNormal * amountReflectedNormal * amountReflectedNormal * amountReflectedNormal * amountReflectedNormal;
    float specularClamped = lerp(round(specular), specular, 0.1);
    
    float3 color = lerp(refractedAndTintedAndConstant.xyz, float3(1,1,1), specularClamped);
    // Output[index2D] = float4(color,1);
    // return;
    if (cell.Alpha > AlphaThreshold)
    {
        Output[index2D] = float4(color, min(cell.Alpha*3, 1));
    }
    else
    {
        Output[index2D] = float4(0,0,0,0);
    }
    // Output[index2D] = float4(cell.NearestNormal, min(cell.Alpha*3, 1));
}

//use circles for uv map...
//then before final rendering... use uv offset for entire render with full resolution.....