// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main
#include "Assets/Scripts/CreateLiquid.cs.hlsl"

float ParticlesLength;
StructuredBuffer<ScreenParticle> ScreenParticles;

float4 CellsDimension;
RWStructuredBuffer<ScreenCell> ScreenCells;

RWTexture2D<float4> Output;
// Texture2D<float4> ScreenGrab;

float3 GetScreenNormal(float2 clipPoint, in ScreenParticle screenParticle)
{
    float distFromCenter = distance(screenParticle.ClipPosition, clipPoint);
    float2 toEdge = clipPoint - screenParticle.ClipPosition;
    float2 toEdgeDir = normalize(toEdge);
    float3 tangent = float3(toEdgeDir.x, toEdgeDir.y, 0);
    float3 ortho = float3(0, 0, 1);

    float distFromCenterNorm = distFromCenter / screenParticle.Radius;

    //todo we need to acos interp it I think not just a lerp it to be correct for spheres
    float3 normal = lerp(ortho, tangent, distFromCenterNorm);
    return normalize(normal);
}

void blendCells(inout ScreenCell cell, in ScreenCell other, float blendAmount)
{
    //todo this breaks normal... stop this
    // cell.NearestNormal = lerp(cell.NearestNormal, other.NearestNormal, blendAmount);
    // cell.Alpha = lerp(cell.Alpha, other.Alpha, blendAmount);
}

[numthreads(8,8,1)]
void main (uint3 id : SV_DispatchThreadID)
{
    int index = id.x;
    float2 index2D = id.xy;
    int indexFlat = id.x + id.y * CellsDimension.x;
    Output[index2D] = id.xyzx;
    
    ScreenCell cell = ScreenCells[indexFlat];
    cell.Alpha = 0;
    cell.NearestNormal = float3(0,0,0);
    cell.NearestParticle = 1000000;
    cell.FarthestParticle = -1000000;

    float2 cellScreenPos = float2((float) id.x / CellsDimension.x, (float) id.y / CellsDimension.y);
    for (int k = 0; k < ParticlesLength; k++)
    {
        ScreenParticle part = ScreenParticles[k];
        //todo make this the distance to the sphere at screen... not just the center
        float screenDist = distance(cellScreenPos, part.ClipPosition.xy);
        if (screenDist < part.Radius)
        {
            float distance = part.CameraDepth;
            cell.Alpha = lerp(cell.Alpha, 1, 0.2f);
            if (distance < cell.NearestParticle)
            {
                cell.NearestNormal = GetScreenNormal(cellScreenPos, part);
            }

            cell.NearestParticle = min(cell.NearestParticle, distance);
            cell.FarthestParticle = max(cell.FarthestParticle, distance);
        }
    }
    //BLUR ------------------
    int horizontalIncrement = 1;
    int verticalIncrement = CellsDimension.x;

    float blendAmount = 0.3;
    blendCells(cell, ScreenCells[indexFlat + horizontalIncrement + horizontalIncrement], blendAmount);
    blendCells(cell, ScreenCells[indexFlat - horizontalIncrement - horizontalIncrement], blendAmount);
    blendCells(cell, ScreenCells[indexFlat + verticalIncrement + verticalIncrement], blendAmount);
    blendCells(cell, ScreenCells[indexFlat - verticalIncrement - verticalIncrement], blendAmount);
    //BLUR ---------------
    
    ScreenCells[indexFlat] = cell;
    Output[index2D] = float4(cell.NearestNormal.xyz, cell.Alpha);
}

