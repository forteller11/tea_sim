// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main
#pragma kernel main2
#include "Assets/Scripts/CreateLiquid.cs.hlsl"

float ParticlesLength;
StructuredBuffer<ScreenParticle> ScreenParticles;

float4 CellsDimension;
RWStructuredBuffer<ScreenCell> ScreenCells;
RWStructuredBuffer<ScreenCell> ScreenCellsBlurred;

float4 ScreenGrabDimensions;
Texture2D<float4> ScreenGrab;
RWTexture2D<float4> Output;

//todo make world normal
float3 GetScreenNormal(float2 clipPoint, in ScreenParticle screenParticle)
{
    float distFromCenter = distance(screenParticle.ClipPosition, clipPoint);
    float2 toEdge = clipPoint - screenParticle.ClipPosition;
    float2 toEdgeDir = normalize(toEdge);
    float3 tangent = float3(toEdgeDir.x, toEdgeDir.y, 0);
    float3 ortho = float3(0, 0, 1);

    float distFromCenterNorm = distFromCenter / screenParticle.Radius;

    //todo we need to acos interp it I think not just a lerp it to be correct for spheres
    float3 normal = lerp(ortho, tangent, distFromCenterNorm);
    return normalize(normal);
}

[numthreads(8,8,1)]
void main (uint3 id : SV_DispatchThreadID)
{
    int indexFlat = id.x + id.y * CellsDimension.x;
    
    ScreenCell cell = ScreenCells[indexFlat];
    cell.Alpha = 0;
    cell.NearestNormal = float3(0,0,-1);
    cell.NearestParticle = 1000000;
    cell.FarthestParticle = -1000000;

    float2 cellScreenPos = float2((float) id.x / CellsDimension.x, (float) id.y / CellsDimension.y);
    for (int k = 0; k < ParticlesLength; k++)
    {
        ScreenParticle part = ScreenParticles[k];
        //todo make this the distance to the sphere at screen... not just the center
        float screenDist = distance(cellScreenPos, part.ClipPosition.xy);
        if (screenDist < part.Radius)
        {
            float distance = part.CameraDepth;
            cell.Alpha = lerp(cell.Alpha, 1, 0.1f);
            if (distance < cell.NearestParticle)
            {
                cell.NearestNormal = GetScreenNormal(cellScreenPos, part);
            }

            cell.NearestParticle = min(cell.NearestParticle, distance);
            cell.FarthestParticle = max(cell.FarthestParticle, distance);
        }
    }

    ScreenCells[indexFlat] = cell;
}

//remember to renormalized at the end!
void weightedAdd(inout ScreenCell cell, in ScreenCell other, float addedWeight)
{
    //todo this breaks normal... stop this
    cell.NearestNormal = lerp(cell.NearestNormal, other.NearestNormal, addedWeight);
    cell.Alpha += other.Alpha * addedWeight;
}

//this isn't technically a box blur because the kernal is not currently shaped like a box... it has 8 pixels missing
//[x][ ][x][ ][x]
//[ ][x][x][x][ ]
//[x][x][x][x][x]
//[ ][x][x][x][ ]
//[x][ ][x][ ][x]
ScreenCell boxBlur(int2 index)
{
    int indexFlat = index.x + index.y * CellsDimension.x;
    int horizontalIncrement = 1;
    int verticalIncrement = CellsDimension.x;

    ScreenCell cell;
    cell.Alpha = 0;
    cell.NearestNormal = float3(0,0,0);
    cell.FarthestParticle = 0;
    cell.NearestParticle = 0;
    
    float selfWeight = 0.16;
    float manhatten1Weight = 0.06;
    float manhatten2Weight = 0.05; //58
    float diagonalWeight1 = 0.05; // 74
    float diagonalWeight2 = 0.05;
    
    weightedAdd(cell, ScreenCells[indexFlat], selfWeight);
    
    //manhatten nearest
    weightedAdd(cell, ScreenCells[indexFlat + horizontalIncrement], manhatten1Weight);
    weightedAdd(cell, ScreenCells[indexFlat - horizontalIncrement], manhatten1Weight);
    weightedAdd(cell, ScreenCells[indexFlat + verticalIncrement], manhatten1Weight);
    weightedAdd(cell, ScreenCells[indexFlat - verticalIncrement], manhatten1Weight);

    //diagonal nearest
    weightedAdd(cell, ScreenCells[indexFlat + horizontalIncrement + verticalIncrement], diagonalWeight1);
    weightedAdd(cell, ScreenCells[indexFlat - horizontalIncrement + verticalIncrement], diagonalWeight1);
    weightedAdd(cell, ScreenCells[indexFlat + horizontalIncrement - verticalIncrement], diagonalWeight1);
    weightedAdd(cell, ScreenCells[indexFlat - horizontalIncrement - verticalIncrement], diagonalWeight1);

    //manhatten non nearest
    weightedAdd(cell, ScreenCells[indexFlat + horizontalIncrement * 2], manhatten2Weight);
    weightedAdd(cell, ScreenCells[indexFlat - horizontalIncrement * 2], manhatten2Weight);
    weightedAdd(cell, ScreenCells[indexFlat + verticalIncrement * 2], manhatten2Weight);
    weightedAdd(cell, ScreenCells[indexFlat - verticalIncrement * 2], manhatten2Weight);

    //diagonal non nearest
    weightedAdd(cell, ScreenCells[indexFlat + (horizontalIncrement + verticalIncrement) * 2], diagonalWeight2);
    weightedAdd(cell, ScreenCells[indexFlat - (horizontalIncrement + verticalIncrement) * 2], diagonalWeight2);
    weightedAdd(cell, ScreenCells[indexFlat + (horizontalIncrement - verticalIncrement) * 2], diagonalWeight2);
    weightedAdd(cell, ScreenCells[indexFlat - (horizontalIncrement - verticalIncrement) * 2], diagonalWeight2);

    cell.NearestNormal = normalize(cell.NearestNormal);
    return cell;
}

//todo go based on output texture
[numthreads(8,8,1)]
void main2 (uint3 id : SV_DispatchThreadID)
{
    float2 index2D = id.xy;
    float2 scaleAmount = ScreenGrabDimensions.xy /CellsDimension.xy;
    float2 index2DGrab = id.xy * scaleAmount;
    
    ScreenCell cell = boxBlur(id.xy);

    //render
    float refractionAmount = 70;
    float2 refractedUV = cell.NearestNormal.xy * refractionAmount * cell.Alpha + index2DGrab;

    float4 blueTint = float4 (.4,.8,1,1);
    float4 blueConstant = float4 (.3,.3,1,1);
    float4 refractedPixel = ScreenGrab[refractedUV];

    float4 refractedAndTinted = blueTint * refractedPixel;
    float4 refractedAndTintedAndConstant = lerp(refractedAndTinted, blueConstant, 0.5);
    
    if (cell.Alpha >  0.2)
    {
        Output[index2D] = float4(refractedAndTintedAndConstant.xyz, cell.Alpha);
    }
    else
    {
        Output[index2D] = float4(0,0,0,0);
    }

    // Output[index2D] = float4(cell.NearestNormal.xyz, 1);
}

//use circles for uv map...
//then before final rendering... use uv offset for entire render with full resolution.....